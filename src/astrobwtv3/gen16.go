// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build ignore
// +build ignore

// Gen generates sais16.go by duplicating functions in sais.go
// using different input types.
// See the comment at the top of sais.go for details.
package main

import (
	"bytes"
	"io/ioutil"
	"log"
	"strings"
)

func main() {
	log.SetPrefix("gen: ")
	log.SetFlags(0)

	data, err := ioutil.ReadFile("sais.cpp")
	if err != nil {
		log.Fatal(err)
	}

	x := bytes.Index(data, []byte("\n//begin"))
	if x < 0 {
		log.Fatal("cannot find //begin marker")
	}

	var buf bytes.Buffer
	buf.Write(data[:x])
	buf.WriteString("\n\n// Code generated by go generate; DO NOT EDIT.\n")

	for {
		x := bytes.Index(data, []byte("\n/*func*/"))
		if x < 0 {
			break
		}
		data = data[x:]
		p := bytes.IndexByte(data, '(')
		if p < 0 {
			p = len(data)
		}
		name := string(data[len("\n/*func*/"):p])

		log.Printf("found function: %s", name);

		x = bytes.Index(data, []byte("\n}//end"))
		if x < 0 {
			log.Fatalf("cannot find end of func %s", name)
		}
		fn := string(data[:x+len("\n}//end")])
		data = data[x+len("\n}"):]

		if strings.HasSuffix(name, "_32") {
			buf.WriteString(fix32.Replace(fn))
			buf.WriteString("\n")
		}
		if strings.HasSuffix(name, "_8_32") {
			// x_8_32 -> x_8_64 done above
			fn = fix8_32.Replace(stripByteOnly(fn))
			buf.WriteString(fix32.Replace(fn))
			buf.WriteString("\n")
		}
	}

	if err := ioutil.WriteFile("sais16.cpp", buf.Bytes(), 0666); err != nil {
		log.Fatal(err)
	}

	data, err = ioutil.ReadFile("sais.h")
	if err != nil {
		log.Fatal(err)
	}

	x = bytes.Index(data, []byte("\n//begin"))
	if x < 0 {
		log.Fatal("cannot find //begin marker")
	}

	buf.Reset()
	buf.Write(data[:x])
	buf.WriteString("\n\n// Code generated by go generate; DO NOT EDIT.\n")

	for {
		x := bytes.Index(data, []byte("\n/*func*/"))
		if x < 0 {
			break
		}
		data = data[x:]
		p := bytes.IndexByte(data, '(')
		if p < 0 {
			p = len(data)
		}
		name := string(data[len("\n/*func*/"):p])

		log.Printf("found function: %s", name);

		x = bytes.Index(data, []byte(");"))
		if x < 0 {
			log.Fatalf("cannot find end of func %s", name)
		}
		fn := string(data[:x+len(");")])
		data = data[x+len(";"):]

		if strings.HasSuffix(name, "_32") {
			buf.WriteString(fix32.Replace(fn))
			buf.WriteString("\n")
		}
		if strings.HasSuffix(name, "_8_32") {
			// x_8_32 -> x_8_64 done above
			fn = fix8_32.Replace(stripByteOnly(fn))
			buf.WriteString(fix32.Replace(fn))
			buf.WriteString("\n")
		}
	}

	buf.WriteString("\n#endif")

	if err := ioutil.WriteFile("sais16.h", buf.Bytes(), 0666); err != nil {
		log.Fatal(err)
	}
}

var fix32 = strings.NewReplacer(
	"32", "16",
	"int32_t", "int16_t",
)

var fix8_32 = strings.NewReplacer(
	"_8_32", "_16",
	"byte", "int16_t",
	"unsigned char", "int16_t",
)

func stripByteOnly(s string) string {
	lines := strings.SplitAfter(s, "\n")
	w := 0
	for _, line := range lines {
		if !strings.Contains(line, "byte-only") {
			lines[w] = line
			w++
		}
	}
	return strings.Join(lines[:w], "")
}